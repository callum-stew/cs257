1S - Convert waxpby to AVX and remove conditional as all values of alpha=1
        1.17s => 0.82
2S - OMP parallel in waxpby
        0.82 => 0.37
3F - Added func to waxpby for when beta=-1
        No change





1S - Added parallel for to sparsemv.c outer for loop
2S - Added parallel for to waxpby.c
3S - Added parallel for to ddot.c | variable difference but minnor
4S - Added m256d vector to ddot.c | not as big a time gain as 3





#include <immintrin.h>

#include "ddot.h"

/**
 * @brief Compute the dot product of two vectors
 * 
 * @param n Number of vector elements
 * @param x Input vector
 * @param y Input vector
 * @param result Pointer to scalar result value
 * @return int 0 if no error
 */
int ddot (const int n, const double * const x, const double * const y, double * const result) {  
  int i;
  int loopFactor = 4;
  int loopN = (n/loopFactor)*loopFactor;
  
  double local_result = 0.0;
  __m256d v_local_result = _mm256_set1_pd(0.0);
  double *local_result_array = _mm_malloc(sizeof(double) * 4, 32);

  if (y==x){
    for (i=0; i<loopN; i+=loopFactor) {
      __m256d v_xi = _mm256_load_pd(x+i);
      v_local_result = _mm256_add_pd(_mm256_mul_pd(v_xi, v_xi), v_local_result);
    }
    for (; i<n; i++) {
      local_result += x[i]*x[i];
    }

  } else {
    for (i=0; i<loopN; i+=loopFactor) {
      __m256d v_xi = _mm256_load_pd(x+i);
      __m256d v_yi = _mm256_load_pd(y+i);
      v_local_result = _mm256_add_pd(_mm256_mul_pd(v_xi, v_yi), v_local_result);
    }
    for (; i<n; i++) {
      local_result += x[i]*y[i];
    }
  }
  _mm256_store_pd(local_result_array, v_local_result);
  local_result += local_result_array[0]+local_result_array[1]+local_result_array[2]+local_result_array[3];

  *result = local_result;

  _mm_free(local_result_array);

  return 0;
}


#include "ddot.h"

/**
 * @brief Compute the dot product of two vectors
 * 
 * @param n Number of vector elements
 * @param x Input vector
 * @param y Input vector
 * @param result Pointer to scalar result value
 * @return int 0 if no error
 */
int ddot (const int n, const double * const x, const double * const y, double * const result) {  
  double local_result = 0.0;
  #pragma omp parallel reduction(+:local_result)
  {
    if (y==x){
      #pragma omp for nowait
      for (int i=0; i<n; i++) {
        local_result += x[i]*x[i];
      }

    } else {
      #pragma omp for nowait
      for (int i=0; i<n; i++) {
        local_result += x[i]*y[i];
      }
    }
  }

  *result = local_result;
  return 0;
}
